/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const AdminConnection = require('composer-admin').AdminConnection;
const BusinessNetworkConnection = require('composer-client').BusinessNetworkConnection;
const { BusinessNetworkDefinition, CertificateUtil, IdCard } = require('composer-common');
const path = require('path');

const chai = require('chai');
chai.should();
chai.use(require('chai-as-promised'));

//const namespaceUsers = 'org.watchain.users';
const namespace = 'org.watchain.firstHand';
const assetType = 'Watch';
const assetNS = namespace + '.' + assetType;
const participantM = namespace + '.' + 'Manufacturer';
const participantCol = namespace + '.' + 'Collector';
const participantCou = namespace + '.' + 'Courier';
const participantI = namespace + '.' + 'Insurer';
const participantA = namespace + '.' + 'Auctioneer';
const participantF = namespace + '.' + 'Fca';
//const participantType3 = 'Courier';
//const participantType4 = 'Auctioneer';
//const participantType5 = 'Insurer';
//const participantM = namespace + '.' + participantM;

describe('Create Watch', () => {
    // In-memory card store for testing so cards are not persisted to the file system
    const cardStore = require('composer-common').NetworkCardStoreManager.getCardStore( { type: 'composer-wallet-inmemory' } );

    // Embedded connection used for local testing
    const connectionProfile = {
        name: 'embedded',
        'x-type': 'embedded'
    };

    // Name of the business network card containing the administrative identity for the business network
    const adminCardName = 'admin';

    // Admin connection to the blockchain, used to deploy the business network
    let adminConnection;

    // This is the business network connection the tests will use.
    let businessNetworkConnection;

    // This is the factory for creating instances of types.
    let factory;

    // These are the identities for Alice and Bob.
    const orisCardName = 'oris';
    const fedeCardName = 'fede';
    const dhlCardName = 'dhl';
    const allianzCardName = 'allianz';
    const sothebysCardName = 'sothebys';
    const fcaCardName = 'fca';
    

    // These are a list of receieved events.
    let events;

    let businessNetworkName;

    before(async () => {
        // Generate certificates for use with the embedded connection
        const credentials = CertificateUtil.generate({ commonName: 'admin' });

        // Identity used with the admin connection to deploy business networks
        const deployerMetadata = {
            version: 1,
            userName: 'PeerAdmin',
            roles: [ 'PeerAdmin', 'ChannelAdmin' ]
        };
        const deployerCard = new IdCard(deployerMetadata, connectionProfile);
        deployerCard.setCredentials(credentials);
        const deployerCardName = 'PeerAdmin';

        adminConnection = new AdminConnection({ cardStore: cardStore });

        await adminConnection.importCard(deployerCardName, deployerCard);
        await adminConnection.connect(deployerCardName);
    });

    /**
     *
     * @param {String} cardName The card name to use for this identity
     * @param {Object} identity The identity details
     */
    async function importCardForIdentity(cardName, identity) {
        const metadata = {
            userName: identity.userID,
            version: 1,
            enrollmentSecret: identity.userSecret,
            businessNetwork: businessNetworkName
        };
        const card = new IdCard(metadata, connectionProfile);
        await adminConnection.importCard(cardName, card);
    }

     /**
     *
     * @param {String} cardName1 The card name to use for this identity
     * @param {Object} identity1 The identity details
     */
    async function importCardForIdentity(cardName1, identity1) {
        const metadata = {
            userName: identity1.userID,
            version: 1,
            enrollmentSecret: identity1.userSecret,
            businessNetwork: businessNetworkName
        };
        const card1 = new IdCard(metadata, connectionProfile);
        await adminConnection.importCard(cardName1, card1);
    }

     /**
     *
     * @param {String} cardName2 The card name to use for this identity
     * @param {Object} identity2 The identity details
     */
    async function importCardForIdentity(cardName2, identity2) {
        const metadata = {
            userName: identity2.userID,
            version: 1,
            enrollmentSecret: identity2.userSecret,
            businessNetwork: businessNetworkName
        };
        const card2 = new IdCard(metadata, connectionProfile);
        await adminConnection.importCard(cardName2, card2);
    }

     /**
     *
     * @param {String} cardName3 The card name to use for this identity
     * @param {Object} identity3 The identity details
     */
    async function importCardForIdentity(cardName3, identity3) {
        const metadata = {
            userName: identity3.userID,
            version: 1,
            enrollmentSecret: identity3.userSecret,
            businessNetwork: businessNetworkName
        };
        const card3 = new IdCard(metadata, connectionProfile);
        await adminConnection.importCard(cardName3, card3);
    }

    /**
     *
     * @param {String} cardName4 The card name to use for this identity
     * @param {Object} identity4 The identity details
     */
    async function importCardForIdentity(cardName4, identity4) {
        const metadata = {
            userName: identity4.userID,
            version: 1,
            enrollmentSecret: identity4.userSecret,
            businessNetwork: businessNetworkName
        };
        const card4 = new IdCard(metadata, connectionProfile);
        await adminConnection.importCard(cardName4, card4);
    }

    /**
     *
     * @param {String} cardName5 The card name to use for this identity
     * @param {Object} identity5 The identity details
     */
    async function importCardForIdentity(cardName5, identity5) {
        const metadata = {
            userName: identity5.userID,
            version: 1,
            enrollmentSecret: identity5.userSecret,
            businessNetwork: businessNetworkName
        };
        const card5 = new IdCard(metadata, connectionProfile);
        await adminConnection.importCard(cardName5, card5);
    }

    // This is called before each test is executed.
    beforeEach(async () => {
        // Generate a business network definition from the project directory.
        let businessNetworkDefinition = await BusinessNetworkDefinition.fromDirectory(path.resolve(__dirname, '..'));
        businessNetworkName = businessNetworkDefinition.getName();
        await adminConnection.install(businessNetworkDefinition);
        const startOptions = {
            networkAdmins: [
                {
                    userName: 'admin',
                    enrollmentSecret: 'adminpw'
                }
            ]
        };
        const adminCards = await adminConnection.start(businessNetworkName, businessNetworkDefinition.getVersion(), startOptions);
        await adminConnection.importCard(adminCardName, adminCards.get('admin'));

        // Create and establish a business network connection
        businessNetworkConnection = new BusinessNetworkConnection({ cardStore: cardStore });
        events = [];
        businessNetworkConnection.on('event', event => {
            events.push(event);
        });
        await businessNetworkConnection.connect(adminCardName);

        // Get the factory for the business network.
        factory = businessNetworkConnection.getBusinessNetwork().getFactory();

        //get the participant registry for manufacturer
        const manufacturerRegistry = await businessNetworkConnection.getParticipantRegistry(participantM);
        // Create the participants.
        const oris = factory.newResource(namespace, 'Manufacturer', 'oris');
        oris.availableBalance = 0.0;
        await manufacturerRegistry.add(oris);

        //get the participant registry for collector
        const collectorRegistry = await businessNetworkConnection.getParticipantRegistry(participantCol);
        // Create the participants.
        const fede = factory.newResource(namespace, 'Collector', 'fede');
        fede.availableBalance = 0.0;
        await collectorRegistry.add(fede);

        //get the participant registry for courier
        const courierRegistry = await businessNetworkConnection.getParticipantRegistry(participantCou);
        // Create the participants.
        const dhl = factory.newResource(namespace, 'Courier', 'dhl');
        //dhl.availableBalance = 0.0;
        await courierRegistry.add(dhl);

        //get the participant registry for insurer
        const insurerRegistry = await businessNetworkConnection.getParticipantRegistry(participantI);
        // Create the participants.
        const allianz = factory.newResource(namespace, 'Insurer', 'allianz');
        //dhl.availableBalance = 0.0;
        await insurerRegistry.add(allianz);

        //get the participant registry for auctioneer
        const auctioneerRegistry = await businessNetworkConnection.getParticipantRegistry(participantA);
        // Create the participants.
        const sothebys = factory.newResource(namespace, 'Auctioneer', 'sothebys');
        //dhl.availableBalance = 0.0;
        await auctioneerRegistry.add(sothebys);

        //get the participant registry for FCA
        const fcaRegistry = await businessNetworkConnection.getParticipantRegistry(participantF);
        // Create the participants.
        const fca = factory.newResource(namespace, 'Fca', 'fca');
        //dhl.availableBalance = 0.0;
        await fcaRegistry.add(fca);

        //get asset registry for watches
        const assetRegistry = await businessNetworkConnection.getAssetRegistry(assetNS);

        //Create the assets owned by manufacturer.
        const watch0 = factory.newResource(namespace, assetType, '0000000000');
        watch0.owner = factory.newRelationship(namespace, 'Manufacturer' , 'oris');
        watch0.ref = '01ST';
        //watch0.stauts = 'NEW';
        watch0.retailPrice = 500;
        watch0.manufacturer = factory.newRelationship(namespace, 'Manufacturer', 'oris');
        // Add the asset.
        await assetRegistry.add(watch0);

        // Issue the identitity for manufacturer
        let identity = await businessNetworkConnection.issueIdentity(participantM + '#oris', 'oris1');
        await importCardForIdentity(orisCardName, identity);
        // Issue the identity for collector
        let identity1 = await businessNetworkConnection.issueIdentity(participantCol + '#fede', 'fede1');
        await importCardForIdentity(fedeCardName, identity);
        // Issue the identity for courier
        let identity2 = await businessNetworkConnection.issueIdentity(participantCou + '#dhl', 'dhl1');
        await importCardForIdentity(dhlCardName, identity);
        // Issue the identity for insurer
        let identity3 = await businessNetworkConnection.issueIdentity(participantI + '#allianz', 'allianz1');
        await importCardForIdentity(allianzCardName, identity);
        // Issue the identity for auctioneer
        let identity4 = await businessNetworkConnection.issueIdentity(participantA + '#sothebys', 'sothebys1');
        await importCardForIdentity(sothebysCardName, identity);
        // Issue the identity for fca
        let identity5 = await businessNetworkConnection.issueIdentity(participantF + '#fca', 'fca1');
        await importCardForIdentity(fcaCardName, identity);
    });

    /**
     * Reconnect using a different identity.
     * @param {String} cardName The name of the card for the identity to use
     */
    async function useIdentity(cardName) {
        await businessNetworkConnection.disconnect();
        businessNetworkConnection = new BusinessNetworkConnection({ cardStore: cardStore });
        events = [];
        businessNetworkConnection.on('event', (event) => {
            events.push(event);
        });
        await businessNetworkConnection.connect(cardName);
        factory = businessNetworkConnection.getBusinessNetwork().getFactory();
    }
    
        it('Manufacturer can add assets that he owns', async () => {
        // Use the identity for Oris.
        await useIdentity(orisCardName);

        // Create the asset.
        let watch1 = factory.newResource(namespace, assetType, '0000000001');
        watch1.owner = factory.newRelationship(namespace, 'Manufacturer', 'oris');
        watch1.ref = '01ST';
        //watch0.stauts = 'NEW';
        watch1.retailPrice = 500;
        watch1.manufacturer = factory.newRelationship(namespace, 'Manufacturer', 'oris');


        // Add the asset, then get the asset.
        const assetRegistry = await businessNetworkConnection.getAssetRegistry(assetNS);
        await assetRegistry.add(watch1);

        // Validate the asset.
        watch1 = await assetRegistry.get('0000000000');
        watch1.owner.getFullyQualifiedIdentifier().should.equal(participantM + '#oris');
        watch1.ref.should.equal('01ST');
        //watch0.status.should.equal('NEW');
        watch1.retailPrice.should.equal(500);
        watch1.manufacturer.getFullyQualifiedIdentifier().should.equal(participantM + '#oris');
    });

    /**it('Manufacturer can submit a transaction to  create a watch', async () => {
        // Use the identity for Alice.
        await useIdentity(orisCardName);

        // Submit the transaction.
        const genesis = factory.newTransaction(namespace, 'CreateWatch');
        let watch0 = factory.newResource(namespace, assetType, '0000000000');
        watch0.owner = factory.newRelationship(namespace, participantM, 'oris');
        watch0.ref = '01ST';
        //watch0.stauts = 'NEW';
        watch0.retailPrice = 500;
        watch0.manufacturer = factory.newRelationship(namespace, participantM, 'oris');

        
        // Add the asset, then get the asset.
        const assetRegistry = await businessNetworkConnection.getAssetRegistry(assetNS);
        await assetRegistry.add(watch0);
        genesis.watch = factory.newRelationship(namespace, assetType, '0000000000');
        await businessNetworkConnection.submitTransaction(genesis);

        // Get the asset.
        watch0 = await assetRegistry.get('0000000000');

        // Validate the asset.
        watch0.owner.getFullyQualifiedIdentifier().should.equal(participantM + '#oris');
        watch0.ref.should.equal('01ST');
        watch0.status.should.equal('NEW');
        watch0.retailPrice.should.equal('500');
        watch0.manufacturer.getFullyQualifiedIdentifier().should.equal(participantM + '#oris');
    
    });*/
});